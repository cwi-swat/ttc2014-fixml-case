\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TTC 2014} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{rascal}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.8]{beramono}
\title{The TTC 2014 FIXML Case: Rascal Solution\thanks{This
    research was supported by the Netherlands Organisation for
    Scientific Research (NWO) Jacquard Grant ``Next Generation
    Auditing: Data-Assurance as a service'' (638.001.214).}}
\author{Pablo Inostroza \\
\institute{Centrum Wiskunde \&\ Informatica (CWI)\\ Amsterdam, The Netherlands}
\email{\href{mailto:pvaldera@cwi.nl}{pvaldera@cwi.nl}}
\and Tijs van der Storm\\
\institute{Centrum Wiskunde \&\ Informatica (CWI)\\ Amsterdam, The Netherlands}
\email{\href{mailto:storm@cwi.nl}{storm@cwi.nl}}
}
\def\authorrunning{Inostroza and Van der Storm}
\def\titlerunning{TTC'14: Rascal}

\begin{document}
\maketitle

\begin{abstract}
Rascal is a meta programming language for processing source code in the broad sense (models, documents, formats, languages, etc.). In this short note we discuss the implementation of the `TTC'14 FIXML to Java, C\# and C++ Case'' in Rascal. In particular we will highlight the challenges and benefits of using a functional programming language for ...
\end{abstract}

\section{Introduction}

Rascal is a meta programming language for source code analysis and transformation~\cite{Rascal,RascalGTTSE}. 
Concretely, it is targeted at analyzing and processing any kind of ``source code in the broad sense''; this includes importing, analyzing, transforming, visualizing and generating, models, data files, program code, documentation etc.
 
Although Rascal features a Java-like syntax, it is a functional programming in that all data is immutable (implemented using persistent data structures), and function programming concepts are used throughout: algebraic data types, pattern matching, higher-order functions, comprehensions etc. 

Specifically for the domain of source code manipulation, however, Rascal features powerful primitives for parsing (context-free grammars), traversal (visit statement), relational analysis (transitive closure, image etc.), and code generation (string templates). 
The standard library includes programming language grammars (e.g., Java), IDE integration
with Eclipse, numerous importers (e.g. XML, CSV, YAML, JSON etc.) and a rich visualization framework. 

For this particular case study, we identify the following challenges:
\begin{itemize}
\item For the same reason, model transformation amounts  non-destructive rewriting. That is, it is impossible to perform in-place updates. This has benefits for reasoning (locality), but might affect performance.
\end{itemize}

In the following sections we discuss the realization of the TTC'14 tasks in Rascal. We conclude the paper with some observations and concluding remarks. 
All code examples  can be found  online at:
\begin{quote}
\url{https://github.com/cwi-swat/ttc2014-fixml--case}
\end{quote}

\section{The transformation}

As proposed in the description of the case study, the solution transformation has been broken down into the following sub transformations:

\begin{enumerate}
\item XML text to model of XML metamodel
\item model of XML metamodel to a metamodel of OO programming languages
\item OO metamodel to program text (for different OO programming languages)
\end{enumerate}

The general approach was to understand what was the sufficient information in order to 

We have addressed all these cases as we proceed to explain.

\subsection{Sub transformation 1: XML text to model of XML metamodel}

Rascal features a XML importer that allows to parse an XML file and map its concrete syntax to a metamodel. Thus, the only necessary code to accomplish this task was this:

\begin{rascal}
Node parseXMLDOM(\CAT{Keyword}{loc} src) = parseXMLDOMTrim(readFile(src));
\end{rascal}

For completeness, we present the internal representation of the XML metamodel, whose essence is captured by these datatypes:

\begin{rascal}
\CAT{Keyword}{data} Node 
     = document(Node root)
     | attribute(Namespace namespace, \CAT{Keyword}{str} name, \CAT{Keyword}{str} text)
     | element(Namespace namespace, \CAT{Keyword}{str} name, \CAT{Keyword}{list}{}[Node] children)
     | charData(\CAT{Keyword}{str} text)
     | cdata(\CAT{Keyword}{str} text)
     | comment(\CAT{Keyword}{str} text)
     | pi(\CAT{Keyword}{str} target, \CAT{Keyword}{str} text)
     | entityRef(\CAT{Keyword}{str} name)
     | charRef(\CAT{Keyword}{int} code)
     ;  
          
\CAT{Keyword}{data} Namespace 
     = namespace(\CAT{Keyword}{str} prefix, \CAT{Keyword}{str} uri)
     | none()
     ;
\end{rascal}

\subsection{Sub transformation 2: XML metamodel to OO metamodel}

We have defined an OO metamodel that suits the purpose of this particular task. This means that it is not necessarily comprehensive enough to model a complex OO system, but it serves as an intermediate model from which all the desired output in this context could be generated. For instance, it is possible to see that the types for representing fields possess an \texttt{altName} field. This is useful to represent unambiguous parameters in the case of C++ code, as required by the particular code style shown in the description of the use case. Once we understood all the necessary and minimum data requirements in the desired variants of the output, we created the OO metamodel.

The following datatypes capture the structure of the OO metamodel:
%\CAT{Keyword}{alias} Id = \CAT{Keyword}{int};
\begin{rascal}
\CAT{Keyword}{data} OOModel = oomodel(\CAT{Keyword}{list}{}[Class] classes);
\CAT{Keyword}{data} Class = class(\CAT{Keyword}{str} name, \CAT{Keyword}{list}{}[Field] literalFields, \CAT{Keyword}{list}{}[Field] objFields);
\CAT{Keyword}{data} Type = tipe(\CAT{Keyword}{str} className);
\CAT{Keyword}{data} Field = objField(Type tipe, \CAT{Keyword}{str} name, \CAT{Keyword}{str} altName, \CAT{Keyword}{list}{}[Field] vals) 
           | literalField(Type tipe, \CAT{Keyword}{str} name, \CAT{Keyword}{str} altName, \CAT{Keyword}{str} val);
\CAT{Keyword}{data} Ref = ref(\CAT{Keyword}{str} container, \CAT{Keyword}{str} field) | ref(\CAT{Keyword}{str} name);
\CAT{Keyword}{data} Statement = assignment(Ref lhs, Ref rhs);
\end{rascal}

In order to map a FIXML model to a OO model, it was necessary to bridge the conceptual gap between both by specifying a transformation from a generic XML model to an OO class using the interpretation described in the description of the case study.  This transformation was specified in 75 SLOC of Rascal code.

\subsection{OO model to program text}

Once we have the OO model, the last step is to \emph{serialize} it as a program in three different OO languages: Java, C\#, and C++. 

These three transformations are quite similar, and the stronger differences they exhibit are related to particular idioms of one implementation in respect to the others, particularly in the case of C++. For instance, although the order in which classes are declared is not relevant in the case of Java and C\#, it definitely matters in the case C++, given its declare-before-use policy. For this reason, we just present the source code of the Java serialization, and discuss afterwards this interesting particularity of the C++ transformation.

\begin{rascal}
\CAT{Keyword}{str} model2java(oomodel(classes)) = 
    intercalate(\CAT{Constant}{"\textbackslash{}n\textbackslash{}n"}, {}[class2javaClass(class) | class \textless{}- classes]);

\CAT{Keyword}{str} class2javaClass(class(name, literalFields, objFields)) =
    \CAT{Constant}{"class \textless{}}name\CAT{Constant}{\textgreater{}
    '\{{}
    '\textless{}}fields2javaFields(literalFields, objFields)\CAT{Constant}{\textgreater{}
    '     \textless{}}name\CAT{Constant}{\textgreater{}()\{{}
    '    \}{}
    '
    '\textless{}}fields2constructor(name, literalFields, objFields)\CAT{Constant}{\textgreater{}
    '\}{}"};
    
\CAT{Keyword}{str} fields2constructor(\CAT{Keyword}{str} className, \CAT{Keyword}{list}{}[Field] literalFields, \CAT{Keyword}{list}{}[Field] objFields)=
    \CAT{Constant}{"    \textless{}}className\CAT{Constant}{\textgreater{}(\textless{}}toParameters(literalFields, objFields)\CAT{Constant}{\textgreater{})\{{} 
    '     \textless{}}\CAT{Keyword}{for} (literalField(\_{}, name, \_{}, \_{}) \textless{}- literalFields)\{{}\CAT{Constant}{\textgreater{}
    '        this.\textless{}}name\CAT{Constant}{\textgreater{} = \textless{}}name\CAT{Constant}{\textgreater{};    \textless{}}\}{}\CAT{Constant}{\textgreater{}
    '      \textless{}}\CAT{Keyword}{for} (objField(\_{}, name, altName, \_{}) \textless{}- objFields)\{{}\CAT{Constant}{\textgreater{}
    '        this.\textless{}}name\CAT{Constant}{\textgreater{} = \textless{}}altName\CAT{Constant}{\textgreater{}; \textless{}}\}{}\CAT{Constant}{\textgreater{}
    '        \}{}"};
    
\CAT{Keyword}{str} toParameters(\CAT{Keyword}{list}{}[Field] litFields, \CAT{Keyword}{list}{}[Field] objFields) =
     intercalate(\CAT{Constant}{", "}, parLst)
     \CAT{Keyword}{when} parLst
             := {}[\CAT{Constant}{"\textless{}}cName\CAT{Constant}{\textgreater{} \textless{}}name\CAT{Constant}{\textgreater{}"} |literalField(tipe(cName), name, \_{},  \_{}) \textless{}- litFields]
               + {}[\CAT{Constant}{"\textless{}}cName\CAT{Constant}{\textgreater{} \textless{}}altName\CAT{Constant}{\textgreater{}"} |objField(tipe(cName), \_{}, altName, \_{}) \textless{}- objFields];

\CAT{Keyword}{str} fields2javaFields(\CAT{Keyword}{list}{}[Field] litFields, \CAT{Keyword}{list}{}[Field] objFields) =
    \CAT{Constant}{"    \textless{}}\CAT{Keyword}{for} (literalField(tipe, name, \_{}, val) \textless{}- litFields)\{{}\CAT{Constant}{\textgreater{}
    '    \textless{}}tipe.className\CAT{Constant}{\textgreater{} \textless{}}name\CAT{Constant}{\textgreater{} = \textbackslash{}"\textless{}}val\CAT{Constant}{\textgreater{}\textbackslash{}"; \textless{}}\}{}\CAT{Constant}{\textgreater{}
    '    \textless{}}\CAT{Keyword}{for} (objField(tipe, name, \_{}, vals) \textless{}- objFields)\{{}\CAT{Constant}{\textgreater{}\textless{}}tipe.className\CAT{Constant}{\textgreater{} \textless{}}name\CAT{Constant}{\textgreater{} =
    '         new \textless{}}tipe.className\CAT{Constant}{\textgreater{}(\textless{}}toArguments(vals)\CAT{Constant}{\textgreater{});
    '     \textless{}}\}{}\CAT{Constant}{\textgreater{}"};

\CAT{Keyword}{str} toArguments(\CAT{Keyword}{list}{}[Field] literalFields, \CAT{Keyword}{list}{}[Field] objFields) =
    intercalate(\CAT{Constant}{", "}, parLst)
    \CAT{Keyword}{when} parLst := {}[\CAT{Constant}{"\textbackslash{}"\textless{}}val\CAT{Constant}{\textgreater{}\textbackslash{}""} |literalField(\_{}, \_{}, \_{},  val) \textless{}- literalFields]
                   + {}[\CAT{Constant}{"new \textless{}}cName\CAT{Constant}{\textgreater{}()"} |objField(tipe(cName), \_{}, \_{}, \_{}) \textless{}- objFields];
\end{rascal}

The most remarkable features of this transformation are the generation of the output by means of the template-like string literals in Rascal. Characteristics like the support of multiline strings, string interpolation (escaping expressions with the < and > characters) and auto-indenting make writing \emph{model-to-text} transformations simple.

As we mentioned, the declare-before-use policy of C++ had to be taken into account in that particular transformation. Below, it is possible to read the code that handles this situation.

\begin{rascal}
\CAT{Keyword}{list}{}[Class] orderClasses(\CAT{Keyword}{list}{}[Class] classes) =
    {}[classesMap{}[cName] | cName \textless{}- reverse(analysis::graphs::Graph::order(depGraph))]
    \CAT{Keyword}{when} classesMap := (className:c | c:class(className, \_{}, \_{}) \textless{}- classes),
         depGraph := \{{}\textless{}className, oName\textgreater{} | class(className, \_{}, oFields) \textless{}- classes
                                         , objField(tipe(oName), \_{}, \_{}, \_{}) \textless{}- oFields\}{};

\CAT{Keyword}{str} model2cpp(oomodel(classes)) = 
    intercalate(\CAT{Constant}{"\textbackslash{}n\textbackslash{}n"}, {}[class2cppClass(class) | class \textless{}- orderClasses(classes)]);
\end{rascal}

The \texttt{orderClasses} function uses the \texttt{order} function from the \texttt{analysis::graphs::Graph} module, which computes the topological order of the nodes in a graph. Therefore, the only required task in order to implement the declare-before-use policy was to create a dependency graph between the classes in the model.  The local variable \texttt{depGraph} receives its value from a comprehension that we will explain, as a good example of the advantage of combining Rascal's functional nature and its relational calculus support. Given a set of classes, the comprehension builds a set of tuples (i.e., a binary relation) where its first member is the name of one class being iterated in the first level of iteration, and the second member corresponds to the class name of an object field of such a class. This value is obtained by adding another level of iteration for the object fields of each class.

\section{Concluding Remarks}
Implementing the FIXML case study in Rascal was straightforward, as Rascal was indeed designed for supporting the analysis and transformation of source code artifacts. Because of this, many of the more complex analysis were already provided by standard libraries, e.g., XML parsing and topological sorting. In sum, it took only 179 SLOC to implement the pipeline required to output the code in the three required languages. The most complex part of the assignment was to identify the minimal subset of an OO metamodel that we needed in order to implement this particular use case. By doing that, we avoided unnecessary accidental complexity and conceived a metamodel that was described in just 15 SLOC.

\section{Bibliography}

\nocite{*}
\bibliographystyle{eptcs}
\bibliography{generic}
\end{document}
